package main

import (
	"encoding/json"
	"os"
	"path/filepath"
	"testing"

	"turnstone/config"
)

// TestRunInit verifies that the initialization logic creates the expected
// directories, configuration files, and certificates.
func TestRunInit(t *testing.T) {
	tempDir := t.TempDir()

	if err := runInit(tempDir); err != nil {
		t.Fatalf("runInit failed: %v", err)
	}

	// List of files and directories we expect runInit to generate
	expectedArtifacts := []string{
		// Configs
		"turnstone.json",
		"turnstone.cdc.json",
		// Certs
		"certs/server.crt",
		"certs/server.key",
		"certs/client.crt",
		"certs/client.key",
		"certs/admin.crt",
		"certs/admin.key",
		"certs/cdc.crt",
		"certs/cdc.key",
		"certs/ca.crt",
		// Data Databases (0=System, 16=Last User Database in default config)
		"data/0",
		"data/1",
		"data/16",
	}

	for _, artifact := range expectedArtifacts {
		path := filepath.Join(tempDir, artifact)
		if _, err := os.Stat(path); os.IsNotExist(err) {
			t.Errorf("Expected artifact missing: %s", artifact)
		}
	}
}

// TestGeneratedConfigsValidity ensures that the JSON files generated by runInit
// can be successfully parsed back into their respective configuration structures.
func TestGeneratedConfigsValidity(t *testing.T) {
	tempDir := t.TempDir()
	if err := runInit(tempDir); err != nil {
		t.Fatalf("Setup failed: %v", err)
	}

	t.Run("ServerConfig", func(t *testing.T) {
		path := filepath.Join(tempDir, "turnstone.json")
		data, err := os.ReadFile(path)
		if err != nil {
			t.Fatalf("Read config failed: %v", err)
		}

		var cfg config.Config
		if err := json.Unmarshal(data, &cfg); err != nil {
			t.Errorf("Failed to unmarshal turnstone.json: %v", err)
		}

		// Verify key defaults
		if cfg.Port != ":6379" {
			t.Errorf("Unexpected default port: %s", cfg.Port)
		}
		if cfg.NumberOfDatabases != 16 {
			t.Errorf("Unexpected default databases: %d", cfg.NumberOfDatabases)
		}
	})

	t.Run("CDCConfig", func(t *testing.T) {
		path := filepath.Join(tempDir, "turnstone.cdc.json")
		data, err := os.ReadFile(path)
		if err != nil {
			t.Fatalf("Read CDC config failed: %v", err)
		}

		// Structure matches the anonymous struct in main.go runCDC
		var jsonCfg struct {
			Host      string `json:"host"`
			Partition string `json:"partition"`
			// StartSeq was removed
			StateFile   string `json:"state_file"`
			MetricsAddr string `json:"metrics_addr"`
			TLSCertFile string `json:"tls_cert_file"`
			TLSKeyFile  string `json:"tls_key_file"`
			TLSCAFile   string `json:"tls_ca_file"`
		}

		if err := json.Unmarshal(data, &jsonCfg); err != nil {
			t.Errorf("Failed to unmarshal turnstone.cdc.json: %v", err)
		}

		if jsonCfg.Host == "" {
			t.Error("CDC Host should not be empty")
		}
		if jsonCfg.MetricsAddr != ":9091" {
			t.Errorf("Unexpected CDC metrics addr: %s", jsonCfg.MetricsAddr)
		}
		// Verify new certificate fields
		if jsonCfg.TLSCertFile != "certs/cdc.crt" {
			t.Errorf("Unexpected CDC cert file: %s", jsonCfg.TLSCertFile)
		}
		if jsonCfg.TLSKeyFile != "certs/cdc.key" {
			t.Errorf("Unexpected CDC key file: %s", jsonCfg.TLSKeyFile)
		}
	})
}

// TestLoadClientTLS verifies that the helper function correctly loads
// and parses the certificate pairs generated by runInit.
func TestLoadClientTLS(t *testing.T) {
	tempDir := t.TempDir()
	if err := runInit(tempDir); err != nil {
		t.Fatalf("Setup failed: %v", err)
	}

	certFile := filepath.Join(tempDir, "certs", "client.crt")
	keyFile := filepath.Join(tempDir, "certs", "client.key")
	caFile := filepath.Join(tempDir, "certs", "ca.crt")

	tlsConfig, err := loadClientTLS(certFile, keyFile, caFile)
	if err != nil {
		t.Fatalf("loadClientTLS failed: %v", err)
	}

	if tlsConfig == nil {
		t.Fatal("Returned TLS config is nil")
	}

	// Verify Certificates loaded
	if len(tlsConfig.Certificates) != 1 {
		t.Errorf("Expected 1 client certificate, got %d", len(tlsConfig.Certificates))
	}

	// Verify Root CA pool is populated
	if tlsConfig.RootCAs == nil {
		t.Error("RootCAs pool is nil")
	}
}

// TestLoadClientTLS_Errors checks failure modes for the TLS helper.
func TestLoadClientTLS_Errors(t *testing.T) {
	tempDir := t.TempDir()
	// No runInit, so files don't exist

	_, err := loadClientTLS(
		filepath.Join(tempDir, "missing.crt"),
		filepath.Join(tempDir, "missing.key"),
		filepath.Join(tempDir, "missing.ca"),
	)

	if err == nil {
		t.Error("Expected error loading missing files, got nil")
	}
}

// TestRunInit_Idempotency (optional) checks if running init twice causes issues.
// Note: config.GenerateConfigArtifacts overwrites files, so this should pass without error.
func TestRunInit_Idempotency(t *testing.T) {
	tempDir := t.TempDir()

	if err := runInit(tempDir); err != nil {
		t.Fatalf("First run failed: %v", err)
	}

	if err := runInit(tempDir); err != nil {
		t.Fatalf("Second run failed: %v", err)
	}
}
